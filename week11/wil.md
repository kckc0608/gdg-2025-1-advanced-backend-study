지금까지 기본적인 B-Tree 구조와 데이터 조회 / 삽입 / 삭제 알고리즘을 정리하였다.

실제 B-Tree는 이 기본적인 내용을 기반으로 동시성 제어, on-disk 페이지 표현방식, 형제노드간 링크 여부, 유지보수 프로세스 등 디테일한 구현을 어떻게 했는지에 따라 다양한 종류가 존재한다.



이번 글에서는 각각의 B-Tree 변형체 종류와 그 특징에 대해서 알아볼 것이다.

대략적으로 소개를 먼저 하자면



1. Copy-on-Write B-Tree

B-Tree 와 유사한 구조를 갖고 있으나, 각 페이지의 내용은 변하지 않는다. (immutable)

페이지를 수정할 때는 이전 페이지의 복사본을 만들고, 복사본에 대해 수정한 뒤, 그 복사본을 새로운 공간에 저장하는 방식으로 수정한다.



2. Lazy B-Tree

같은 노드에 대한 쓰기 연산을 버퍼에 모아두었다가 한번에 수행함으로써 디스크 I/O 횟수를 줄이는 방식을 사용한다.



3. FD-Tree

버퍼링 대신 다음 글에서 알아볼 LSM Tree 와 유사한 방식을 사용하는 B-Tree

FD-Tree 의 버퍼는 작은 B-Tree 안에서 수정되며, 이 트리가 가득 차면 그 내용이 '변하지 않는 run' 에 쓰여진다.

또한 update 연산은 서로 다른 immutable run level 사이에 높은 레벨부터 낮은 레벨 방향으로 전파된다.



4. Bw-Tree

B-Tree 노드를 append-only 방식으로만 쓰여지는 작은 부분으로 나눈다.

그리고 서로 다른 노드에 대한 update 를 모았다가 함께 실행함으로써 작은 단위의 쓰기 연산 비용을 줄일 수 있다.



5. Cache-oblivious B-Tree

메모리에서 사용하는 것과 유사한 구조의 on-disk 데이터 구조를 사용하는 B-Tree 이다.





Copy-on-write
특징
어떤 데이터베이스에서는 동시에 실행되고 있는 연산이 있을 때 데이터 무결성을 지키는 방법으로, 지난 글에서 정리했던 '래치' 대신 copy-on-write 기법을 사용한다.

이 기법은 데이터를 수정하려고 할 때, 원본에 대해 바로 수정하는 대신, 복사본을 먼저 만들고, 이 복사본에 대해서 수정함으로써 두가지 트리 구조가 병렬적으로 존재하도록 만든다.



이전 버전 트리구조는 writer 와 동시에 실행되고 있던 reader 가 접근하여 데이터를 읽도록 하는 용도로 사용된다.

수정된 버전의 트리에 접근하려는 writer 는 이 버전의 쓰기 연산이 다 끝날 때까지 기다렸다가 접근한다.

새로운 페이지 계층구조가 완성된 후에는 최상위 페이지의 포인터가 자동으로 업데이트 된다.



단점
이 방식은 다른 방식 대비 더 많은 공간과 처리 시간을 필요로 하는 단점이 있다.

전체 페이지를 다 복사해야 하는 오버헤드가 존재하고, 이전 버전 페이지는 짧은 시간 동안만 남아있다고 해도, 동시에 실행중인 reader 의 이전 페이지 사용이 모두 종료되어야만 이전 버전 페이지를 제거할 수 있기 때문이다.



그래도 B-Tree는 일반적으로 깊이가 얕기 때문에 이 구현 방식의 단순함과 장점들은 이 단점들을 상쇄하는 경우가 많다.



장점
이 방식의 제일 큰 장점은 reader 가 동기화될 필요가 없다는 것이다.

한번 쓰여진 페이지는 수정될 수 없고 (immutable) 추가적인 래치없이 접근할 수 있기 때문이다.

writer 가 복사된 페이지에 대해 쓰기 작업을 수행하는 동안, reader는 계속해서 원본 페이지를 읽고 있으므로 writer 의 작업을 방해하지 않는다.

또한 모든 operation 은 미완성 상태의 (연산이 진행중인) 페이지를 볼 수 없으며, 시스템 충돌이 발생하더라도 페이지를 망가진 상태로 남겨두지 않는다. 최상위 페이지 포인터의 변경은 쓰기 작업이 다 진행된 이후에 바뀌므로, 쓰기 중에 충돌이 발생했다면 이전의 쓰기가 완료되었던 과거 버전을 계속해서 보기 때문이다.





구현
copy-on-write 방식을 사용하는 스토리지 엔진으로는 LDBM (Lightening Memory-Mapped Database) 가 있다.

이 스토리지 엔진은 OpenLDAP 프로젝트에서 사용되는, key-value 기반의 저장소이며

그 설계와 구조 상 특징에 의해 페이지 캐시, WAL, 체크포인트, 압축과 같은 기능이 필요하지 않다.



LDBM 의 또 다른 특징은 single-level 데이터 저장소라는 점이다.

따라서 read, write 연산은 memory map 에 대해 직접 수행되며, 어플리케이션 레벨에서 추가적인 사이 계층이 존재하지 않는다.

이 말은 추가적인 페이지 실체화 과정이 필요없으며, 중간 버퍼에 데이터를 복사하는 일 없이 메모리 맵에서 직접 데이터를 읽어들일 수 있다는 것을 말한다.

(페이지 실체화 = 압축을 했다면 압축을 해제해서 원본 페이지를 복원하는 것과 같이 실제 페이지 내용을 복구하는 과정)



업데이트 연산을 수행할 때는, 루트 노드부터 업데이트할 데이터가 들어있는 leaf node 까지 모든 경로를 복사해둔다.

업데이트가 상위 노드로 전파되면서 상위노드의 데이터 구성 역시 변경될 수 있기 때문이다.



LDBM 에서 root 노드는 최신 버전과 현재 수정중인 버전, 딱 2가지 버전만 있으면 충분하다.

모든 쓰기 연산은 root 노드를 거쳐야 하기 때문이다.

새로운 root 노드가 만들어진 뒤에는 이후에 진행되는 새로운 read, write 연선은 이전 root 에 접근할 수 없고, 이전 root 에 대한 read 연산 실행이 모두 완료된 이후에는 이전 root 노드 페이지를 회수하고, 다시 사용가능한 상태로 만든다.



LDBM 은 append-only 방식으로 동작하기 때문에 sibiling 노드를 사용하지 않는다.

sibling node 를 사용하려면 sibling 노드의 사이에 데이터를 삽입할 수 있어야 하는데, append-only 로는 중간 삽입을 할 수 없기 때문이다.

따라서 범위 연산을 수행할 때, 옆 리프노드의 데이터를 조회해야 하는 상황이 온다면, 다시 루트로 돌아가서 탐색해야 한다.



이와 같은 설계 방식을 따르면, 굳이 여러 버전의 과거 데이터를 명시적으로 저장할 필요가 없다. (비효율적)

LDBM 자체가 복사본을 만드는 방식이기 때문에 MVCC 용으로도 사용될 수 있으며, 현재 실행중인 read 트랜잭션의 처리가 가능하다.

그리고 read 와 write 연산의 동시성 제어를 lock 없이도 할 수 있다.







노드 업데이트 작업에 대한 추상화
디스크 내 페이지를 업데이트 하려면, 먼저 그 페이지에 해당하는 메모리 내 표현 데이터를 업데이트 해야 한다.

그런데 페이지 데이터를 메모리에 표현하는 방법은 다양하게 있다.

node 의 직접적인 캐싱 버전을 메모리에 둘 수도 있고, wrapper object 로 감싸서 두거나, 스토리지 엔진을 구현한 언어에서 지원하는 자체 표현구조를 사용할 수도 있다.



- node 의 직접적인 캐싱 버전 저장

c와 같이 자동으로 메모리를 관리하는 도구가 없는 언어에서는 b-tree 노드에 저장된 바이너리 raw 데이터를 그 언어에서 표현하는 형식에 맞춰 번역하고, 언어에서 지원하는 포인터르 raw 데이터를 다룬다.

이 경우, node 의 정보는 그 '구조' 에 대한 정의 데이터만 들어있고, 실제 컨텐츠 데이터는 포인터를 통해 접근하여 runtime 에 자료형에 맞는 실제 데이터로 변환한다.

이 언어들을 사용하는 경우, 주로 페이지 캐시에 의해 관리되는 메모리 공간을 가리키거나, 메모리 맵핑을 사용하여 구현한다.



- wrapper 오브젝트

이 방식은 노드 뒤에 있는 버퍼에 접근할 수 있도록 wrapper object 를 제공하는 방식이다.

wrapper object 는 B-Tree 에 대한 변경사항을 실제 디스크와 메모리에 실체화하며, 변경사항을 backing buffer 에 반영한다.

이 접근법은 자동으로 메모리를 관리해주는 기능이 있는 언어에서 자주 사용된다.



- 스토리지 엔진 구현 언어의 자체 기능 활용

B-tree 노드는 스토리지 엔진의 구현 언어에서 사용하는 object, 또는 structure 로 실체화될 수 있다.

그리고 이 구조를 활용하여 insert, update, delete 연산을 수행한다.

변경사항을 디스크에 반영할 때는 (flush) 먼저 메모리에 반영하고, 그 다음에 디스크에 반영한다.



이 방식의 장점은 raw page 에 대한 변경이 중간 객체에 의해 페이지 접근 동작과 분리되어 동시성 접근을 단순화할 수 있다는 것이다.

대신 메모리 내 같은 페이지 안에 raw page 버전과 언어에 특화되도록 실체화된 버전을 모두 저장해야 하기 때문에 메모리 오버헤드가 크다.





Lazy B-Tree
lazy b-tree 는 b-tree 의 업데이트 비용을 줄이고, 동시성 제어, 업데이트 연산 모두에 더 적합한 가벼운 인메모리 구조를 사용하여 업데이트 연산을 버퍼에 모으고, 업데이트 연산의 전파를 늦추는 방식의 알고리즘을 사용한다.



구현
Lazy B-Tree 의 대표적인 구현은 몽고디비의 스토리지 엔진인 Wired Tiger 가 있다.

각각의 row 는 on-disk 페이지와 in-memory 페이지에 대해서 서로 다른 포맷을 사용하는 B-Tree 구현을 저장하고 있다.



처음에는 디스크상 페이지 이미지로부터 clean page 를 만드는데, clean page 는 index 로만 구성되어있다.

update 연산이 발생하면 일단 update 연산은 update buffer 에 저장해둔다.



update buffer 는 읽기 연산을 수행하는 동안 접근해서, 이때 디스크 상 페이지 데이터와 병합하여 값을 읽어들인다.

페이지가 flush 되면 update buffer 내용이 page content 와 병합되어 디스크에 덮어 쓰여진다.

만약 새로 덮어쓰는 페이지의 크기가 최대 크기를 넘었다면 여러 페이지로 쪼개진다.

update 결과는 skiplist 를 사용해서 구현하는데, 이 자료구조는 탐색 트리와 비슷한 복잡도를 갖고 있으면서도 동시성 제어에는 더 효과적이다.



장점
이 방식의 장점은 페이지 업데이트와 트리 구조의 수정 과정이 백그라운드 스레드에 의해서 수행되어, 읽기 / 쓰기 연산을 수행할 때, 업데이트 과정이 끝나기를 기다리지 않고도 수행할 수 있다는 장점이 있다.





변형 : Lazy-Adaptive Tree
LA-Tree 는 모든 개별 노드의 update 과정을 버퍼에 저장하는 대신, 여러 노드를 하나의 '서브 트리' 단위로 묶어서 서브 트리 단위로 update buffer 를 두도록 구현한다. 이 update buffer 에는 서브트리 내 노드들에 대해 발생하는 모든 연산이 버퍼링된다.



데이터 레코드를 삽입할 때는 새로운 엔트리를 루트 노드 update buffer 에 먼저 추가한다.

만약 이 버퍼가 가득 차면, 그 내용물을 복사하고, 루트 하단의 자식 노드로 내용을 쪼개서 복사한다.

이 과정은 재귀적으로 반복될 수 있으며, 제일 낮은 레벨에 도달하면 복사되어 쪼개진 노드는 리프노드가 된다.



LA-Tree 에서 버퍼는 계층적 의존성과 cascade 속성을 갖고 있다.

따라서 모든 업데이트 연산은 높은 레벨에서 낮은 레벨 방향으로 전파될 수 있으며, update 연산이 리프노드에 도달하면 모아두었던 insert, update, delete 연산을 실행하고, 실행 결과를 트리에 한번에 반영한다.



따라서 update 연산을 각 노드마다 순차적으로 모두 실행해두는 것이 아니라, 상위 계층에만 일단 버퍼에 저장해두고 그대로 끝내는 것이다.

그리고 페이지는 한번의 실행(run)으로 업데이트 되어, 결과적으로 더 적은 디스크 접근과 구조 변경이라는 장점을 갖게된다.



버퍼링 접근 방법은 쓰기 연산을 모았다가 한번에 실행하므로 트리의 update 시간을 최적화한다.

Lazy B-tree 와 LA-tree 모두 추가적인 인-메모리 버퍼 조회와 과거 디스크 데이터와의 merge 작업을 수행해야 한다.





FD-Tree
HDD 에서는 헤더가 이동하는 시간이 필요하기 때문에, SSD 에서는 가비지 콜렉션에 의한 추가적인 I/O 가 필요하기 때문에 잦은 랜덤 엑세스는 성능에 좋지 않다.

따라서 디스크에 접근하여 쓰는 횟수를 줄이는 것은 성능상 중요한데, 버퍼링은 자잘한 쓰기를 여러번하는 대신, 이들을 모았다가 크게 한번 씀으로써 I/O 횟수를 줄여주는 보편적인 아이디어이다.



그런데 B-Tree 구조를 유지하는 것은 잦은 랜덤 엑세스가 필요하다.

leaf 노드에 데이터를 수정할 때, 이 수정이 상위 페이지로 전파되기도 하기 때문이다.

하지만 만약 랜덤 엑세스를 피하고, 모든 쓰기 작업을 한번에 수행할 수 있다면 어떨까?



지금까지는 각 노드 단위 또는 노드 그룹 단위로 버퍼링하는 기법에 대해 정리하였다.

이 기법에 대한 대안으로 append-only 스토리지와 merge 프로세스를 사용해서 '서로 다른' 노드에 대한 업데이트 연산까지 모두 모았다가 한번에 수행하는 방법이 있다.

이 아이디어는 나중에 정리할 LSM 트리에서도 사용된다.

따라서 우리가 수행하는 모든 쓰기 연산은 특정 '노드' 를 대상으로 하지 않으며, 단지 append-only 스토리지에 차곡차곡 쌓이기만 한다.

이 기법을 사용한 B-Tree 변형 중 하나가 바로 Flash Disk Tree, FD-Tree 이다.



FD-Tree 는 크기가 작고 변경될 수 있는 head tree 하나와 수정될 수 없는 여러 개의 sorted run 으로 구성되어 있다.

이 기법에서는 random access 가 필요한 surface area, head tree 의 크기를 제한한다.

head tree 는 update 연산들을 버퍼링하고, 만약 트리가 가득차면 그 내용들이 변경되지 않는 run 으로 변환된다.

만약 새로 만들어진 run 의 크기가 특정 임계치를 넘었다면 그 내용들이 다음 level 에 병합되고, 위에서부터 아래로 점진적으로 데이터 레코드를 전파한다.



FD tree 는 각 레벨간 포인터를 관리할 때 Fractional Cascading 기법을 사용한다.

이 기법은 연속적으로 연결된 정렬된 배열 안에서 원소를 log 시간에 빠르게 찾고자 할 때 사용하는 기법이다.

직관적으로 떠올리는 아이디어는 이분 탐색을 배열 수 만큼 반복해서  k log n 시간에 찾는 것이지만, 이 기법은 로그 시간의 전처리를 통해log 시간에 원하는 아이템을 찾을 수 있는 기법이다.



첫 번째 배열에서 이분 탐색으로 log n 시간에 원하는 항목을 찾고, 그 항목에서부터는 상수 시간에 탐색을 진행한다.

이는 각 배열의 원소는 자신과 연결된 요소가 있기 때문에 가능하다.



각 배열의 레벨 간 지름길은 인접한 배열간 gap 을 최소로 만드는 다리를 만듦으로써 구성된다.

각 다리는 낮은 레벨에 요소가 있다면 이를 높은 레벨로 요소를 가져오고, 가져온 요소에 대한 포인터를 둠으로써 만들어진다.



이런 연결 관계는 2차원 배열을 사용한 맵핑으로 구현할 수 있지만, 포인터를 저장하고 관리하는데 오버헤드가 너무 크다.

그렇다고 만약 높은 레벨에 이미 존재하는 요소에 대해서만 포인터 맵을 구성한다면, 각 요소간 갭이 너무 커저버리는 문제가 발생한다.

이런 딜레마를 해결하기 위해 우리는 모든 N번째 아이템을 낮은 레벨에서 높은 레벨로 가져온다.



예를 들어, 



A1 = [12, 24, 32, 34, 39]

A2 = [22, 25, 28, 30, 35]

A3 = [11, 16, 24, 26, 30]



이렇게 배열이 존재할 때, 낮은 레벨에서 높은 레벨로 짝수번째 요소를 올려보낸다.



A1 = [12, 24, 25, 30, 32, 34, 39]

A2 = [16, 22, 25, 26, 28, 30, 35]

A3 = [11, 16, 24, 26, 30]



이때 낮은 레벨에서 높은 레벨로 올려진 25, 30, 16, 26 은 그 낮은 레벨의 배열로 가는 다리의 시작점 역할을 한다.



이제 A1 ~ A3 모든 배열에서 탐색을 수행한다면 제일 높은 레벨에서 이분탐색을 수행하고,

그 결과에 따라 그 다음 레벨의 탐색 범위는 포인터를 기준으로 크게 줄어든다.



이를 통해 FD-Tree 에서는 여러개의 multiple sorted run 을 연결하고, 이 안에서 데이터를 찾는 시간을 줄일 수 있다.



이제 run 에 대해서 이해할 준비가 되었다.

FD-Tree 의 run 은 변경불가능하며, 정렬되어있는 배열이다.

그리고 이 run 은 크기가 지수적으로 증가하고, 그 기준 factor 는 k 이다.



처음에는 아무런 run 이 없다가 head tree 가 가득차면 첫번째 run 이 생성된다.

또 다시 head tree 가 가득차면 새로운 run 이 기존의 첫번째 run 과 병합된다.

만약 상위 레벨의 run 크기가 특정 임계치에 도달했다면 (지수적으로 증가하는 레벨별 크기 제한)

이전 레벨의 run 과 병합하여 새로운 lower level run 을 만든다.

만약 lower level run 이 이미 존재했다면 higher level run 과 병합한 결과에 의해 대체된다.



FD-Tree 는 sorted run 내 모든 아이템에 접근할 수 있도록 fractional cascading 의 변형을 사용한다.

바로 lower level 의 head 데이터를 상위로 올려보내서 포인터로 사용하는 것이다.

이로 인해 lower level 에서 탐색하는 비용이 줄어든다.



FD-Tree 는 in-place 에서 데이터를 업데이트 할 수 없기 때문에, 일부 레벨에서 같은 키를 가진 데이터 레코드가 여러번 나타날 수 있다.

FD-Tree 에서 데이터의 삭제는 tombstone 을 사용해서 처리된다. (논문에서는 이를 filter entry 라고 부른다)

즉, 이 데이터 레코드는 삭제되었다고 표시하는 데이터를 남기는 것이다.

그리고 그 데이터 레코드의 키를 가진 lower level 데이터 역시 모두 삭제된다.

데이터의 실제 삭제는 tombstone 이 lower level 로 전파될 때 이루어진다.



 