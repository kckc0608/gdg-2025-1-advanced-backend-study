# 4장 B-Tree 구현 (1)

## B-Tree Organization
### Page Header
페이지 헤더에는 페이지 탐색, 관리, 최적화를 위한 메타데이터가 들어있음
- 페이지 내 셀 개수
- 페이지 크기
- 페이지 레이아웃 버전 (스토리지 엔진 버전이 업데이트 되면서 레이아웃 형태가 변할 수 있는데, 과거 버전 레이아웃으로 저장된 페이지를 맞춰 읽기 위해서 버전 명시)
    -> SQLite 의 경우, file format 이라는 이름으로 버전을 관리하고 있음

#### 매직 넘버
- 파일 헤더 / 페이지 헤더에는 '매직 넘버' 가 포함되어 페이지나 파일의 내용이 깨지지 않았으며, 이 파일이 페이지임을 나타내는 용도로 사용됨
- 예를 들어 'PAGE' 에 해당하는 글자 4개를 파일 맨 처음에 넣어두었다고 하면, 파일을 읽을 때 처음에 'PAGE' 로 읽히는지 확인해서 이 파일이 페이지이고 바이트 정렬이 잘 되었다는 걸 확인할 수 있음

#### 형제 링크
- B-Tree 안에서 같은 레벨에 있는 노드의 이웃 형제끼리 링크를 걸어두는 것   
- 부모 노드를 경유하지 않고, 이웃 노드로 한번에 넘어갈 수 있으므로 벌크 연산을 처리하기 좋음.   
- 하지만 노드의 삽입, 삭제가 발생하여 배치가 변경되면 형제 노드 포인터의 값도 맞춰서 바꿔주어야 하므로 복잡도가 늘어남   
- 형제 링크도 페이지 헤더에 저장할 수 있음.   
- 형제 링크의 단점은 merge / split 없이 형제 노드가 업데이트 되는 상황에서 추가적인 lock 이 필요하다는 것

#### Rightmost Pointer
- 하나의 노드에는 N 개의 키와 N+1 개의 포인터가 있음. 따라서 왼쪽부터 하나씩 pair 를 맞추면 가장 오른쪽 포인터는 페어가 존재하지 않음
- SQLite 에서는 이런 rightmost pointer 를 헤더에 저장해두고, 노드에는 저장하지 않음으로써 셀 공간을 보다 깔끔하게 관리함
- rightmost pointer 가 가리키는 노드가 split / merge 되면 포인터가 가리키는 값 역시 바뀌어야 함. 쪼개진 이전 노드는 rightmost pointer 가 들어있는 노드의 새로운 포인터와 연결되고, 새로 생긴 노드가 rightmost pointer 가 가리키는 노드가 됨.

#### Node High Key
- 어떤 구현에서는 rightmost pointer 도 노드에 저장하는 대신, 이 포인터와 짝을 맞출 키를 같이 붙이는 식으로 구현하기도 함.
- 이 키를 node high key 라고 하며, 그 노드가 가질 수 있는 가장 큰 값의 키를 갖고 있음
- 이렇게 구성된 트리를 Blink-Tree 라고도 부르며, Postgresql 이 이렇게 구현했음
- 이 구현에서는 짝에 맺어진 키 값 미만의 값은 무조건 그 키의 페어 포인터를 따라가도록 구현할 수 있으므로 더 간단히 구현할 수 있음

#### Overflow Page
- 가변 크기 데이터를 저장할 때, 가변 크기 페이지를 활용하기에는 성능 상의 한계가 있음
- 따라서 고정 크기 페이지로 가변 크기 데이터를 저장하기 위해 오버플로우 페이지를 활용함.
- 페이지 안에는 N개의 데이터가 들어있을 수 있음 -> 가변 크기를 저장한다고 페이지를 꽉 채워서 저장하면 N개를 저장하지 못할 수 있음
- 따라서 페이지 안에서도 하나의 데이터가 차지할 수 있는 공간을 정해놔야 함. (max_payload_size = page size / N)
- 오버플로우 페이지를 사용했을 때도 단편화 문제가 발생할 수 있으므로, 이를 관리하는 체계가 필요함
- 키 값을 저장할 때 오버플로우 페이지를 활용했다고 해서 모든 오버플로우페이지를 통해 키를 읽을 필요는 없다. 키는 비교해서 다음 노드를 찾아가는 것이 목적인데, 키의 cardinality 가 높아서 첫 페이지 만으로도 비교가 가능한 경우가 많기 때문이다.
- 물론 데이터 값을 읽을 때는 모든 페이지를 다 읽어야 하지만, 이 연산은 그렇게 자주 있지 않아서 성능 이슈가 크지는 않다.
- 모든 데이터가 페이지 크기를 넘어설 것 같다면, BLOB storage 같은 다른 스토리지를 활용하는 것이 좋다.

## Binary Search & Collecting Breadcrumbs
### Binary Search
- 이진 탐색을 사용하려면 배열이 정렬되어 있어야 함. 따라서 B-Tree 각 노드도 키를 정렬된 상태로 유지해야 함
- 이진 탐색을 구현할 때, 찾는 값이 있으면 그 인덱스를, 없으면 insertion point 를 음수로 반환함.
- Slotted Page 는 셀과 셀 포인터를 분리해서 관리하므로, 이 경우에는 이진 탐색을 셀 포인터에 대해 수행해야 한다.

### Collecting Breadcrumbs
- split, merge 연산은 부모로 전파될 수 있다. (쪼개서 부모로 보냈는데, 부모노 가득차서 쪼개고, ... 반복)
- 전파를 구현할 때는 부모로부터 리프노드로 가는 과정에서 거쳤던 부모 노드 포인터와, 부모 노드 안에서 사용했던 포인터 인덱스를 스택에 저장해두었다가, 위로 올라가야 할 때는 스택에서 pop 하면서 위로 가는 방식으로 구현할 수 있다.

### 형제 노드를 사용할 때 발생하는 동시성 문제
- 형제 노드를 타고 탐색할 때 동시성 문제가 발생할 수 있다.
- 예를 들어 두 스레드가 같은 레벨의 노드에서 벌크 연산을 수행하는데 한 스레드는 왼쪽에서 오른쪽, 다른 스레드는 오른쪽에서 왼쪽으로 간다면 중간에서 부딪히면서 데드락이 발생할 수 있다.
- 이 문제를 해결하기 위해 락의 방향을 단방향으로 제한할 수 있으며 WiredTiger 는 항상 부모노드에서 자식노드 방향으로 락이 걸리도록 제한하고 형제노드를 사용하지 않음으로써 이 문제를 해결하였다.
