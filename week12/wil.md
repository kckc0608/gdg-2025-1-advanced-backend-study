Bw-Tree
B-Tree 에서 in-place 쓰기 연산을 구현할 때 몇 가지 해결해야 할 문제점이 있다.



1. 쓰기 증폭 (write amplification)

B-Tree 페이지에 대한 연속적인 쓰기 연산은, 디스크에 있는 페이지를 매 쓰기마다 복사하도록 만들 수 있다.



2. 공간 증폭 (space amplification)

쓰기 연산이 가능하려면 해당 데이터를 쓸 여유 공간을 미리 잡아놔야 한다.

즉, 요청 데이터를 나타내는 byte 값을 위해서 비어있는 바이트와 페이지의 남은 공간을 전송해야 한다.



3. 동시성 문제 해결과 래치를 조작하는데 들어가는 복잡도



기존의 update 연산을 버퍼링하는 접근법은 1, 2 번 문제 해결에 도움이 되지만 3번 문제에 대한 해결책은 되지 못한다.

따라서 이 3가지 문제를 한번에 해결하기 위해, 이전과는 완전히 다른 접근 방법을 시도할 수 있다.



바로 서로 다른 노드에 대한 update 연산을 append-only storage 를 이용해서 모아두고, 각 노드를 chain 으로 연결하고, 노드와 노드 사이의 포인터를 한번의 CAS 연산으로 설정할 수 있는 인메모리 자료구조를 사용해서 나중에 한번에 수행(batch)하는 것이다.



이 접근법으로 구현한 트리를 Buzzword-Tree (Bw-Tree) 라고 부른다.



구현
- chain 업데이트

Bw-Tree 는 수정사항과 별개로 base node 를 쓴다.

수정 사항은 delta node 에 기록되며, 이들은 chain 을 형성한다.

chian 은 가장 최근의 수정에서부터 오래된 수정버전까지 연결된 연결리스트이며, 제일 마지막에는 base node 가 있다.

각각의 update 연산은 기존 node 를 수정하지 않고, 따로 별개 delta node로 저장된다. 

delta node 는 삽입, 수정, 삭제를 나타낼 수 있다.



base node, delta node 의 크기는 page 에 정렬되지 않을 수 있기 때문에, 이들은 연속적으로 저장된다.

그리고 이 두 노드는 업데이트 연산이 진행되는 동안에는 바뀌지 않기 때문에 (모든 수정 작업은 기존 연결 리스트에 새로운 노드를 붙이는 append-only 방식 작업) 추가적인 공간을 잡아둘 필요가 없다.



이렇게 node 에 대한 정보를 물리적인 것이 아닌 논리적인 형태로 갖고 있으면, 디스크 공간을 미리 할당할 필요도 없고, 노드의 크기를 사전에 고정해서 강제할 필요도 없으며, 이들이 연속된 메모리 세그먼트 상에 존재하도록 만들 필요도 없다.



물론 단점도 존재한다.

읽기 연산을 수행하는 동안 모든 delta 노드를 순회해서 base node 에 변경 사항을 적용하여 현재 상태의 노드를 재구성해야 하기 때문이다. (LA-Tree 에서 했던 것과 비슷하다)



- Compare and Swap 을 활용한 동시성 제어

디스크 상의 트리 구조에서 자식 노드 앞에 새로운 항목을 추가하는 prepend 방식은 유지보수 비용이 높다.

가장 최신 상태를 가리키는 delta node 를 가리키는 포인터를 부모 노드에 계속해서 갱신해야 하기 때문이다.

(그래야 그 최신노드부터 부모노드를 향해 거꾸로 타고 가면서 변경사항을 반영할 수 있음. 시작점은 부모이지만, 내용 읽기는 부모노드가 가리키는 가장 최신 노드에서 시작)



그래서 Bw-Tree 노드는 base node 와 여러개의 delta node 로 구성되며, 각 노드는 논리적 식별자를 갖는다.

그리고 이 논리 식별자를 디스크 상 물리 위치와 매핑하는 '매핑 테이블' 을 메모리 안에 갖고 있으며, 이 매핑 테이블 덕분에 락(latch)을 없앨 수 있다.

매핑 테이블에 값을 쓸 때는 락을 잡는 대신 매핑 테이블의 물리적 오프셋에 대해 CAS 전략을 사용해 값을 수정하기 때문이다.



Bw-Tree 의 수정 연산은 다음 단계를 따라간다.



1. 루트부터 리프까지 트리를 따라 가면서, 수정할 leaf node 를 찾는다. 이때 매핑 테이블은 찾는 대상 노드의 base node 또는 delta 노드를 참조하고 있다.

2. 새로운 델타 노드는 기존 delta node 또는 base node 와 연결되어 chain 앞에 삽입된다.

3. 메모리에 있는 매핑 테이블에서 해당 논리 ID 가 가리키는 주소를 새 delta node 로 변경한다.
이 과정은 CAS 로 수행되어 동시에 접근한 다른 스레드가 있어도 원자적 연산을 지원하기 때문에 읽기 연산ㅇ느 업데이트 전 / 후 중 하나의 상태만 보게 된다. (변경 중인 상태는 보지 않음)



만약 두 스레드가 동시에 접근해서 CAS 연산을 수행하면 둘 중 하나만 성공하고 나머지는 실패해서 다시 시도하게 된다.



- 구조 수정 연산 (Structural Modification Operations, SMOs)

Bw-Tree 는 논리적으로 B-Tree 와 유사한 구조를 갖고 있다.

따라서 노드가 너무 커져서 overflow 되거나 너무 작아져서 underflow 되면 적절히 split / merge 연산을 수행해야 한다.

하지만 이에 대한 구현은 기존 B-Tree 와 완전히 다르다.



- split 연산

분할할 노드의 논리적 내용을 먼저 하나로 통합한다. delta node 부터 base node 로 따라가며 체인을 병합하고 하나의 온전한 상태로 데이터를 확정하여 저장한다.

그 후, 분할 기준점 (mid point) 오른쪽 데이터를 새로운 페이지에 저장한다.



먼저 분할할 때는 현재 분할 중임을 알리기 위해 split delta node 를 기존 노드에 붙이며,

이 노드는 분할 기준 키와 새로 만든 형제 노드의 링크를 갖고 있다.



처음에 부모 노드는 새로운 형제 노드의 존재를 모른다.

따라서 reader 는 split delta node 를 통해 형제 노드로 이동해야 한다.

부모 노드가 업데이트 되어 새로운 노드를 직접 참조하게 되면 그 때 split 연산이 완료된다.

사실 부모 노드 업데이트는 성능 최적화를 위해 수행하는 것일 뿐, 안해도 데이터 접근에는 영향이 없다.

Bw-Tree 는 락이 없으므로, 어떤 스레드든 중간 상태의 SMO 를 만나면 작업을 이어 받아 마무리 해야 한다.



- merge 연산

오른쪽 형제 노드를 삭제 대상으로 표시하는 remove delta node 를 추가하고, 왼쪽 노드에는 merge delta node 를 만들어서 오른쪽 노드의 내용을 논리적으로 왼쪽 노드에 통합한다.

병합을 완료하기 위해, 부모 노드에서 오른쪽 노드를 제거한다.



- 동시성 제어

동시에 여러 구조를 수정하지 않게 하기 위해, abort delta node 를 부모 노드에 추가한다.

이 노드는 일종의 쓰기 락처럼 작동하여 다른 스레드의 SMO를 방지한다.

SMO가 끝나면 abort delta node 도 제거된다.



- root 분할

만약 root 노드가 분할되면 트리의 높이가 1 증가한다.

새로운 루트 노드를 만들어 기존 루트와 새로운 형제 노드를 자식으로 연결한다.



- 병합과 가비지 컬렉션

그런데 Bw-Tree 의 delta 체인은 관리를 하지 않으면 계속 길어질 수 있다.

이 길이가 너무 길어지면 읽기 성능이 점점 나빠지므로, 적절한 길이를 유지해야 한다.

만약 델타 체인 길이가 일정 임계치를 넘으면 해당 노드를 재구성하여 기존 base node 와 모든 delta 를 병합하는 과정을 수행한다.

이렇게 만들어진 새 base node 는 디스크의 새로운 곳에 저장하고, 매핑 테이블에서 포인터를 갱신한다.



이 과정은 LLAMA 와 log-structed storage 를 통해 관리한다.

로그 기반 저장소는 가비지 수집, 노드 병합, 위치 재조정을 담당한다.

노드 병합 이후에는 기존 base, delta 노드가 매핑 테이블에서 제거되어 다시 접근되지 않지만 아직 메모리에서 해제하지는 못한다.

현재 진행중인 스레드가 여전히 참조중일 수 있기 때문이다.



Bw-Tree 는 락이 없기 때문에 어떤 reader 가 어떤 node 를 보는지 알 수 없어 별도의 추적 방법이 필요하다.

이를 위해 epoch-based reclamation 을 활용하는다.

이는 특정 노드가 제거되었더라도, 해당 에포크 시점 또는 이전 에포크에서 시작한 모든 reader 가 종료될 때까지 메모리에서 보존했다가, 모두 종료되면 그때 메모리에서 제거하는 방법이다.



요약하면 Bw-Tree 는 기존 B-Tree 대비 write amplification 을 해결하고, lock-free 기반에다, 캐시 친화적인 구조로 성능을 향상한 구현 방법이다.

Sled 라는 스토리지 엔진에서 이 방식을 차용하고 있고, CMU Database Group 은 OpenBw-Tree 를 만들고 관련된 구현 가이드도 제공한다.



Cache-Oblivious B-Tree
oblivious : 의식하지 못하는, 눈치채지 못하는
→ cache-oblivious : 캐시를 의식하지 않는

cache-oblivious ↔️ cache-aware
디스크는 블록 단위로 구성 → ‘디스크 - 캐시’ 간 데이터 전송도 블록 단위
블록 내 데이터 일부를 조회할 때도 전체 블록을 다 읽어야 함= 블록의 크기와 같은 하드웨어 정보를 알고 있다는 뜻= cache-aware

→ 하드웨어 상 캐시 구조가 어떻게 되어있는지 몰라도 최적의 성능을 낼 수 있는 B-Tree



B-Tree 의 성능은 블록 크기, 노드 크기, cache-line 정렬 등 여러 요소에 영향을 받음
Cache-Oblivious B-Tree 는 이런 요소를 몰라도, 메모리 계층 구조에 상관없이 최적의 성능에 근접한 성능을 냄
메모리 계층 구조에 상관없다는 것은 하드웨어 특성에 영향을 받지 않는다는 것→ 서로 다른 머신 위에서도 스토리지 엔진 수정없이 잘 작동함



지금까지는 B-Tree 를 ‘page cache - disk' 의 2계층 관점에서만 살펴봄
각 계층에서 효율적으로 동작하는 2개의 코드 모듈만 작성하면 되므로 알고리즘 설계가 비교적 간단함

하지만 성능이 중요하다면?
메모리, CPU 캐시, 디스크 계층을 모두 고려한 더 복잡한 계층 관계에서 프로그래밍 해야 함
이 경우에는 각 계층에서의 알고리즘 일반화가 어려워짐





하지만 Cache-Oblivious 알고리즘을 사용하면
실제로는 다단계 메모리 계층 구조를 갖고 있어도, 2단계 메모리 모델에서 동작하는 것처럼 추상화할 수 있음
즉, 플랫폼에 특화된 파라미터 설정 없이도, 계층 간 데이터 전송 횟수를 상수 복잡도로 유지할 수 있음





Cache-Oblivious B-Tree 는 정적 B-Tree와 Packed Array로 구성

정적 B-Tree
index file 역할 수행
리프 노드의 값(packed array 에 대한 포인터)은 바뀌지만, 트리의 구조는 변하지 않음 (split, merge 없음)

Packed Array
data file 역할 수행 (실제 데이터 보유)
데이터 추가시 형태를 바꿔주는 오버헤드를 줄이기 위해 미리 빈 공간 (gap) 을 만들어둠



이때 정적 B-Tree 는 van Emde Boas Layout 형태로 저장됨
결과적으로 같은 서브트리 내 노드들이 메모리, 디스크 상에서 서로 인접하게 저장되어 있음

그리고 인덱스를 저장하면 탐색 경로상 거쳐가는 노드를 자연스럽게 함께 캐싱하는 효과가 있음



정적 B-Tree 는 변하지 않고, 그저 packed array 에 대한 인덱스 역할만 수행
데이터의 삽입 / 수정 / 삭제 에 대한 데이터 반영은 packed array 에서 이루어짐

packed array 는 연속된 메모리 덩어리
추가적으로 데이터를 삽입할 것을 대비해서, 밀도 임계값 기준으로 여유 공간 (gap) 을 비워둠→ relocation 횟수 감소
packed array 가 가득차거나, 너무 비면 rebuild→ 이때 정적 B-Tree 도 같이 rebuild



효율적인 B-Tree 구현을 할 수 있는 흥미로운 아이디어
on-disk 구조를 메모리에서 구성하는 것과 비슷하게 구성하는 특징



하지만 이론을 넘어서 실제로 쓰이지는 않고 있음
하드웨어를 신경쓰지 않는다고 했지만, 실제로는 하드웨어 영향이 존재함
캐시 로딩은 추상화되어 있지만, 실제 데이터 I/O는 각 하드웨어 특성에 맞는 블록 단위로 이루어지고 있음
캐싱 & 캐시 방출 과정의 오버헤드는 여전히 존재
블록 전송 복잡도
cache-aware B-tree 와 cache-oblivious b-tree 의 블록 전송 복잡도가 이론상 동일

만약 ‘비휘발성 & (블록 단위가 아닌) 바이트 단위 접근이 가능한 저장장치’ 가 보편화 된다면 달라질 수도..